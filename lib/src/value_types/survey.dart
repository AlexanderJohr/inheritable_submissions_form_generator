import 'dart:collection';
import 'dart:convert';

import 'package:built_collection/built_collection.dart';
import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';
import 'package:built_value/standard_json_plugin.dart';
import 'package:collection/collection.dart';
import 'package:get_it/get_it.dart';
import 'package:json_to_survey/src/value_types/choice_question_extensions.dart';
import 'package:json_to_survey/src/store/store.dart';

import 'package:json_to_survey/src/value_types/submission_extensions.dart';
import 'package:postgres/postgres.dart' show Result;

import '../view_model/view_models.dart';

part 'survey.g.dart';

/// Generated by the Build Value Template: bvs (Built Value Serializers)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
@SerializersFor([
  Submission,
  SurveyStructure,
  ReuseSurveyEntry,
  SingleChoiceQuestion,
  MultipleChoiceQuestion,
  FreeTextQuestion,
  CheckAllConditions,
  ContainsAnyOf,
  ContainsNoneOf,
  Survey,
  Concretisation,
  TextConcretisation,
  DecimalConcretisation,
  MengenVorgabeConcretisation,
  ZeitVorgabeConcretisation,
  ChoiceQuestionAnswer,
  SurveyEntryPath,
  SurveyEntryPathElement,
  LinkOtherSurveyQuestion,
  SubmissionLink,
  ChoiceAnswerValidationResult,
  QuestionError,
  ChoiceQuestionHasNoAnswersError,
  SingelChoiceQuestionHasToManyAnswersError,
  ChoiceQuestionHasDuplicateAnswersError,
  ChoiceQuestionHasAnswersButPathIsDisabledError,
  PathIsDisabledButHasAnsweredSubquestionsError
])
final Serializers serializers = (_$serializers.toBuilder()..addPlugin(StandardJsonPlugin(discriminator: "type")))
    .build(); //final Serializers serializers = (_$serializers.toBuilder()
//      ..addBuilderFactory(
//          const FullType(
//              BuiltList, [FullType(HasValidationErrorMessage)]),
//          () => ListBuilder<HasValidationErrorMessage>())
//      ..addPlugin(StandardJsonPlugin(discriminator: "type")))
//    .build();

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class SurveyStructure implements Built<SurveyStructure, SurveyStructureBuilder> {
  BuiltList<SurveyEntry> get definitions;

  BuiltList<SurveyEntry> get questions;

  SurveyStructure._();
  factory SurveyStructure([void Function(SurveyStructureBuilder) updates]) = _$SurveyStructure;

  Object? toJson() {
    return serializers.serializeWith(SurveyStructure.serializer, this);
  }

  static SurveyStructure? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(SurveyStructure.serializer, json);
  }

  static Serializer<SurveyStructure> get serializer => _$surveyStructureSerializer;
}

abstract class ChoiceBase {
  Set<ChoiceQuestionAnswer> getAnswersOfInheritingSubmissions({required Submission submission, required ViewModel vm, required SurveyEntryPath path});

  Set<ChoiceQuestionAnswer> getAnswersOfInheritingSubmissionsRecursivly(
      {required Submission submission, required ViewModel vm, required SurveyEntryPath path});
}

@BuiltValue(instantiable: false)
abstract class Disableable {
  Condition? get enabledIf;
}

// TODO: sollte ein Survey Entry nicht immer eine ID haben
@BuiltValue(instantiable: false)
abstract class SurveyEntry implements Disableable {
  BuiltMap<String, bool>? get allowedConcretisations;
}

extension SurveyEntryExtensions on SurveyEntry {
  Question resolveConcreteQuestion(Survey type) {
    final reuseableQuestionsMap = type.reuseableQuestionsMap;

    final surveyEntry = this;
    if (surveyEntry is Question) {
      return surveyEntry;
    } else if (surveyEntry is ReuseSurveyEntry) {
      final resolvedSubQuestion = reuseableQuestionsMap[surveyEntry.reuseId];

      //TODO: Use Switch Expression
      if (resolvedSubQuestion is MultipleChoiceQuestion) {
        return resolvedSubQuestion.rebuild((b) => b.allowedConcretisations = surveyEntry.allowedConcretisations?.toBuilder());
      } else if (resolvedSubQuestion is SingleChoiceQuestion) {
        return resolvedSubQuestion.rebuild((b) => b.allowedConcretisations = surveyEntry.allowedConcretisations?.toBuilder());
      }
      throw ArgumentError("[resolvedSubQuestion] should either be [SingleChoiceQuestion] or [MultipleChoiceQuestion]");
    } else {
      throw AssertionError("A [SurveyEntry] should either be a [Question] or a [ReuseSurveyEntry].");
    }
  }
}

abstract class ReuseSurveyEntry implements SurveyEntry, Built<ReuseSurveyEntry, ReuseSurveyEntryBuilder> {
  String get reuseId;

  ReuseSurveyEntry._();
  factory ReuseSurveyEntry([void Function(ReuseSurveyEntryBuilder) updates]) = _$ReuseSurveyEntry;

  Object? toJson() {
    return serializers.serializeWith(ReuseSurveyEntry.serializer, this);
  }

  static ReuseSurveyEntry? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(ReuseSurveyEntry.serializer, json);
  }

  static Serializer<ReuseSurveyEntry> get serializer => _$reuseSurveyEntrySerializer;
}

@BuiltValue(instantiable: false)
abstract class Question implements SurveyEntry {
  String get id;
  String get title;
  String? get description;
}

extension QuestionExtension on Question {
  SurveyEntryPath get toTopLevelPath => SurveyEntryPath((b) => b..leafQuestion = id);
}

abstract class LinkOtherSurveyQuestion implements Question, Built<LinkOtherSurveyQuestion, LinkOtherSurveyQuestionBuilder> {
  LinkOtherSurveyQuestion._();
  factory LinkOtherSurveyQuestion([void Function(LinkOtherSurveyQuestionBuilder) updates]) = _$LinkOtherSurveyQuestion;

  Object? toJson() {
    return serializers.serializeWith(LinkOtherSurveyQuestion.serializer, this);
  }

  static LinkOtherSurveyQuestion? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(LinkOtherSurveyQuestion.serializer, json);
  }

  static Serializer<LinkOtherSurveyQuestion> get serializer => _$linkOtherSurveyQuestionSerializer;
}

@BuiltValue(instantiable: false)
abstract class ChoiceQuestion implements Question {
  BuiltList<Choice> get choices;
}

extension ChoiceQuestionExtension on ChoiceQuestion {
  Choice? getChoiceByValue(String? value) => choices.singleWhereOrNull((choice) => choice.value == value);
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class Choice implements ChoiceBase, Disableable, Built<Choice, ChoiceBuilder> {
  BuiltMap<String, bool>? get allowedConcretisations;

  String get value;
  String get title;
  String? get description;

  BuiltList<SurveyEntry> get subQuestions;

  @override
  Set<ChoiceQuestionAnswer> getAnswersOfInheritingSubmissions(
      {required Submission submission, required ViewModel vm, required SurveyEntryPath path}) {
    return submission.getChildren(vm).expand((child) => child.getAnswers(vm: vm, path: path)).toSet();
  }

  @override
  Set<ChoiceQuestionAnswer> getAnswersOfInheritingSubmissionsRecursivly(
      {required Submission submission, required ViewModel vm, required SurveyEntryPath path}) {
    final children = getAnswersOfInheritingSubmissions(submission: submission, vm: vm, path: path);

    final childrenOfChildren =
        children.expand((child) => child.getAnswersOfInheritingSubmissionsRecursivly(submission: submission, vm: vm, path: path));

    return {...children, ...childrenOfChildren};
  }

  Choice._();
  factory Choice([void Function(ChoiceBuilder) updates]) = _$Choice;

  Object? toJson() {
    return serializers.serializeWith(Choice.serializer, this);
  }

  static Choice? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(Choice.serializer, json);
  }

  static Serializer<Choice> get serializer => _$choiceSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class SingleChoiceQuestion implements ChoiceQuestion, Built<SingleChoiceQuestion, SingleChoiceQuestionBuilder> {
  SingleChoiceQuestion._();
  factory SingleChoiceQuestion([void Function(SingleChoiceQuestionBuilder) updates]) = _$SingleChoiceQuestion;

  Object? toJson() {
    return serializers.serializeWith(SingleChoiceQuestion.serializer, this);
  }

  static SingleChoiceQuestion? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(SingleChoiceQuestion.serializer, json);
  }

  static Serializer<SingleChoiceQuestion> get serializer => _$singleChoiceQuestionSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class MultipleChoiceQuestion implements ChoiceQuestion, Built<MultipleChoiceQuestion, MultipleChoiceQuestionBuilder> {
  MultipleChoiceQuestion._();
  factory MultipleChoiceQuestion([void Function(MultipleChoiceQuestionBuilder) updates]) = _$MultipleChoiceQuestion;

  Object? toJson() {
    return serializers.serializeWith(MultipleChoiceQuestion.serializer, this);
  }

  static MultipleChoiceQuestion? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(MultipleChoiceQuestion.serializer, json);
  }

  static Serializer<MultipleChoiceQuestion> get serializer => _$multipleChoiceQuestionSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class FreeTextQuestion implements Question, Built<FreeTextQuestion, FreeTextQuestionBuilder> {
  FreeTextQuestion._();
  factory FreeTextQuestion([void Function(FreeTextQuestionBuilder) updates]) = _$FreeTextQuestion;

  Object? toJson() {
    return serializers.serializeWith(FreeTextQuestion.serializer, this);
  }

  static FreeTextQuestion? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(FreeTextQuestion.serializer, json);
  }

  static Serializer<FreeTextQuestion> get serializer => _$freeTextQuestionSerializer;
}

typedef GetFieldValues = BuiltSet<String> Function(String field);

abstract mixin class HasDependentFields {
  Set<String> getDependentFields();
}

@BuiltValue(instantiable: false)
abstract class Condition with HasDependentFields {
  bool check(GetFieldValues getFieldValuesDelegate);
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class CheckAllConditions implements Condition, Built<CheckAllConditions, CheckAllConditionsBuilder> {
  BuiltList<Condition> get conditions;

  @override
  Set<String> getDependentFields() => conditions.map((c) => c.getDependentFields()).expand((f) => f).toSet();

  @override
  bool check(GetFieldValues getFieldValuesDelegate) => conditions.every((condition) => condition.check(getFieldValuesDelegate));

  CheckAllConditions._();
  factory CheckAllConditions([void Function(CheckAllConditionsBuilder) updates]) = _$CheckAllConditions;

  Object? toJson() {
    return serializers.serializeWith(CheckAllConditions.serializer, this);
  }

  static CheckAllConditions? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(CheckAllConditions.serializer, json);
  }

  static Serializer<CheckAllConditions> get serializer => _$checkAllConditionsSerializer;
}

@BuiltValue(instantiable: false)
abstract class FieldContainsValuesCondition implements Condition {
  String get field;
  BuiltSet<String> get values;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class ContainsAnyOf implements FieldContainsValuesCondition, Built<ContainsAnyOf, ContainsAnyOfBuilder> {
  @override
  bool check(GetFieldValues getFieldValuesDelegate) => values.intersection(getFieldValuesDelegate(field)).isNotEmpty;

  @override
  Set<String> getDependentFields() => {field};

  ContainsAnyOf._();
  factory ContainsAnyOf([void Function(ContainsAnyOfBuilder) updates]) = _$ContainsAnyOf;

  Object? toJson() {
    return serializers.serializeWith(ContainsAnyOf.serializer, this);
  }

  static ContainsAnyOf? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(ContainsAnyOf.serializer, json);
  }

  static Serializer<ContainsAnyOf> get serializer => _$containsAnyOfSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class ContainsNoneOf implements FieldContainsValuesCondition, Built<ContainsNoneOf, ContainsNoneOfBuilder> {
  @override
  bool check(GetFieldValues getFieldValuesDelegate) => values.intersection(getFieldValuesDelegate(field)).isEmpty;

  @override
  Set<String> getDependentFields() => {field};

  ContainsNoneOf._();
  factory ContainsNoneOf([void Function(ContainsNoneOfBuilder) updates]) = _$ContainsNoneOf;

  Object? toJson() {
    return serializers.serializeWith(ContainsNoneOf.serializer, this);
  }

  static ContainsNoneOf? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(ContainsNoneOf.serializer, json);
  }

  static Serializer<ContainsNoneOf> get serializer => _$containsNoneOfSerializer;
}

@BuiltValue(instantiable: false)
abstract class SurveyEntryInput {
  String get id;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class Survey implements Built<Survey, SurveyBuilder> {
  int get id;
  String get name;
  String get description;
  SurveyStructure get structure;

  Survey._();
  factory Survey([void Function(SurveyBuilder) updates]) = _$Survey;

  String toMarkdown() {
    final buffer = StringBuffer();

    final questions = structure.questions;

    questionToMarkdown(SurveyEntry surveyEntry, {int level = 0}) {
      final reuseableQuestionsMap = this.reuseableQuestionsMap;

      if (surveyEntry is ReuseSurveyEntry) {
        surveyEntry = reuseableQuestionsMap[surveyEntry.reuseId]!;
      }

      if (surveyEntry is Question) {
        String questionIndent = "  " * (level * 2);
        buffer.writeln("$questionIndent* __${surveyEntry.title.trim()}__");
        if (surveyEntry.description != null) {
          buffer.writeln("$questionIndent _${surveyEntry.description!.trim()}_");
        }
      }

      if (surveyEntry is ChoiceQuestion) {
        final choices = surveyEntry.choices;

        for (var choice in choices) {
          String choiceIndent = "  " * (level * 2 + 1);

          buffer.writeln("$choiceIndent* __${choice.title.trim()}__");
          if (choice.description != null) {
            buffer.writeln("$choiceIndent  _${choice.description!.trim()}_");
          }

          for (var subQuestion in choice.subQuestions) {
            questionToMarkdown(subQuestion, level: level + 1);
          }
        }
        buffer.writeln("");
      }
    }

    for (var i = 0; i < questions.length; i++) {
      final question = questions[i];
      questionToMarkdown(question);
    }

    return buffer.toString();
  }

  Object? toJson() {
    return serializers.serializeWith(Survey.serializer, this);
  }

  static Survey? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(Survey.serializer, json);
  }

  static BuiltList<Survey> fromMappedResultsQuery(List<Map<String, Map<String, dynamic>>> mappedResultsQuery) {
    final surveyTypes = mappedResultsQuery.map((row) => row["survey"]).whereNotNull().map((map) => Survey.fromJson(map)).whereNotNull().toBuiltList();

    return surveyTypes;
  }

  static BuiltList<Survey> fromResultList(Result result) {
    final columnNames = result.schema.columns.map((column) => column.columnName!).toList();
    List<Map<String, dynamic>> jsonResult = result.map((row) => Map.fromIterables(columnNames, row)).toList();
    final surveyTypes = jsonResult.map((map) => Survey.fromJson(map)).whereNotNull().toBuiltList();
    return surveyTypes;
  }

  @memoized
  Map<String, Question> get reuseableQuestionsMap {
    final definitions = structure.definitions;

    final reusableQuestionTypes = definitions.whereType<Question>().toList();

    return <String, Question>{for (var q in reusableQuestionTypes) q.id: q};
  }

  @memoized
  QuestionsAndChoicesByPath get questionsAndChoicesByPath {
    final questionsQueue = Queue<Question>();
    final questions = structure.questions.map((se) => se.resolveConcreteQuestion(this));
    questionsQueue.addAll(questions);

    Map<SurveyEntryPath, Question> questionByPathMap = {};
    Map<SurveyEntryPath, Choice> choicesByPathMap = {};

    void addQuestionToMap(SurveyEntry question, {required SurveyEntryPath path}) {
      final leafQuestion = path.leafQuestion;

      final resolvedQuestion = question.resolveConcreteQuestion(this);
      questionByPathMap[path] = resolvedQuestion;

      if (resolvedQuestion is ChoiceQuestion) {
        final choices = resolvedQuestion.choices;

        for (var choice in choices) {
          final choicePath = path.rebuild((b) => b
            ..chainElements.add(SurveyEntryPathElement((b) => b
              ..question = leafQuestion
              ..answer = choice.value))
            ..leafQuestion = null);
          choicesByPathMap[choicePath] = choice;

          final subQuestions = choice.subQuestions;

          for (var subQuestion in subQuestions) {
            final resolvedSubQuestion = subQuestion.resolveConcreteQuestion(this);

            final subQuestionPath = choicePath.rebuild((b) => b.leafQuestion = resolvedSubQuestion.id);
            addQuestionToMap(subQuestion, path: subQuestionPath);
          }
        }
      }
    }

    for (var question in questions) {
      addQuestionToMap(question, path: SurveyEntryPath((b) => b.leafQuestion = question.id));
    }

    return QuestionsAndChoicesByPath(questionByPathMap, choicesByPathMap);
  }

  bool validate() {
    final definitions = structure.definitions;
    final questions = structure.questions;
    final topLevelQuestions = [definitions, questions].flattened.toList();

    final subQuestions = topLevelQuestions.whereType<ChoiceQuestion>().map((question) => question.extractSubquestionsRecursive()).flattened.toList();

    final allQuestions = [topLevelQuestions, subQuestions].flattened;

    final allDependentFields = allQuestions.map((e) => e.enabledIf?.getDependentFields()).whereNotNull().flattened.toSet();

    final allIds = allQuestions.whereType<Question>().map((e) => e.id).toSet();

    final invalidDependentFields = allDependentFields.whereNot((field) => allIds.contains(field));

    if (invalidDependentFields.isNotEmpty) {
      throw StateError("Die Felder ${invalidDependentFields.join(", ")} aus den Anzeigebedingungen existieren nicht in der Formularstruktur.");
    }

    return true;
  }

  static Serializer<Survey> get serializer => _$surveySerializer;
}

class QuestionsAndChoicesByPath {
  final Map<SurveyEntryPath, Question> questionByPathMap;
  final Map<SurveyEntryPath, Choice> choicesByPathMap;

  QuestionsAndChoicesByPath(this.questionByPathMap, this.choicesByPathMap);
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class Submission implements Built<Submission, SubmissionBuilder> {
  int get id;
  @BuiltValueField(wireName: "survey_id")
  int get surveyId;
  String get title;

  @BuiltValueField(wireName: "created_by")
  String get createdBy;

  @BuiltValueField(wireName: "created_date")
  DateTime get createdDate;

  Submission._();
  factory Submission([void Function(SubmissionBuilder)? updates]) = _$Submission;

  Object? toJson() {
    return serializers.serializeWith(Submission.serializer, this);
  }

  static Submission? fromJson(Map<String, dynamic> json) {
    final createdDate = json['created_date'];

    if (createdDate is DateTime) {
      json['created_date'] = serializers.serialize(createdDate, specifiedType: const FullType(DateTime));
    }

    return serializers.deserializeWith(Submission.serializer, json);
  }

  static BuiltList<Submission> fromColumnMapSet(List<Map<String, dynamic>> columnMapSet) {
    final submissions = columnMapSet.map((map) => Submission.fromJson(map)).whereNotNull().toBuiltList();

    return submissions;
  }

  static BuiltList<Submission> fromMappedResultsQuery(List<Map<String, Map<String, dynamic>>> mappedResultsQuery) {
    final submissions =
        mappedResultsQuery.map((row) => row["submission"]).whereNotNull().map((map) => Submission.fromJson(map)).whereNotNull().toBuiltList();

    return submissions;
  }

  static BuiltList<Submission> fromResultList(Result result) {
    final columnNames = result.schema.columns.map((column) => column.columnName!).toList();
    List<Map<String, dynamic>> jsonResult = result.map((row) => Map.fromIterables(columnNames, row)).toList();
    final submissionTypes = jsonResult.map((map) => Submission.fromJson(map)).whereNotNull().toBuiltList();
    return submissionTypes;
  }

  static Serializer<Submission> get serializer => _$submissionSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class SubmissionLink implements Built<SubmissionLink, SubmissionLinkBuilder> {
  int get id;

  @BuiltValueField(wireName: "parent_id")
  int get parentId;

  @BuiltValueField(wireName: "child_id")
  int get childId;

  @BuiltValueField(wireName: "choice_question_answer_parent")
  int get choiceQuestionAnswerParent;

  String get relationship;

  SubmissionLink._();
  factory SubmissionLink([void Function(SubmissionLinkBuilder)? updates]) = _$SubmissionLink;

  Object? toJson() {
    return serializers.serializeWith(SubmissionLink.serializer, this);
  }

  static SubmissionLink? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(SubmissionLink.serializer, json);
  }

  static BuiltList<SubmissionLink> fromMappedResultsQuery(List<Map<String, Map<String, dynamic>>> mappedResultsQuery) {
    final submissionLinks = mappedResultsQuery
        .map((row) => row["submission_link"])
        .whereNotNull()
        .map((map) => SubmissionLink.fromJson(map))
        .whereNotNull()
        .toBuiltList();

    return submissionLinks;
  }

  static BuiltList<SubmissionLink> fromResultList(Result result) {
    final columnNames = result.schema.columns.map((column) => column.columnName!).toList();
    List<Map<String, dynamic>> jsonResult = result.map((row) => Map.fromIterables(columnNames, row)).toList();
    final submissionLinks = jsonResult.map((map) => SubmissionLink.fromJson(map)).whereNotNull().toBuiltList();
    return submissionLinks;
  }

  static Serializer<SubmissionLink> get serializer => _$submissionLinkSerializer;

  SubmissionLink getNewLink(
      {required BuiltList<ChoiceQuestionAnswer> answersBeforeInsert,
      required BuiltList<ChoiceQuestionAnswer> answersAfterInsert,
      required Submission newSubmission}) {
    final newLink = rebuild((b) {
      final oldParentId = choiceQuestionAnswerParent;
      final oldAnswer = answersBeforeInsert.singleWhere((a) => a.id == oldParentId);
      final newAnswer = oldAnswer.getAnswerAfterInsert(returnedAnswersFromInsert: answersAfterInsert);
      b
        ..childId = newSubmission.id
        ..choiceQuestionAnswerParent = newAnswer.id;
    });
    return newLink;
  }
}

abstract class ChoiceQuestionAnswer implements ChoiceBase, Built<ChoiceQuestionAnswer, ChoiceQuestionAnswerBuilder> {
  int get id;

  @BuiltValueField(wireName: "submission_id")
  int get submissionId;

  String get question;

  @BuiltValueField(wireName: "linked_submission_id")
  int get linkedSubmissionId;

  String get answer;

  @BuiltValueField(wireName: "parent_id")
  int? get parentId;

  bool equalsAllButId(ChoiceQuestionAnswer other) {
    bool idDiffers = id != other.id;

    bool submissionIdEquals = submissionId == other.submissionId;
    bool questionEquals = question == other.question;
    bool linkedSubmissionIdEquals = linkedSubmissionId == other.linkedSubmissionId;
    bool answerEquals = answer == other.answer;
    bool parentIdEquals = parentId == other.parentId;

    return idDiffers && submissionIdEquals && questionEquals && linkedSubmissionIdEquals && answerEquals && parentIdEquals;
  }

  bool isOwnedBySubmission(Submission submission) {
    return linkedSubmissionId == submissionId && submissionId == submission.id;
  }

  bool isOwnedOrInheritedBySubmission(Submission submission) {
    return submissionId == submission.id;
  }

  bool isInheritingFromSubmission(Submission submission) {
    return linkedSubmissionId == submission.id;
  }

  Choice? getChoice({required ChoiceQuestion question}) => question.choices.singleWhereOrNull((choice) => choice.value == answer);

  String getChoiceTitle({required ChoiceQuestion question}) => getChoice(question: question)?.title ?? answer;

  ChoiceQuestionAnswer._();
  factory ChoiceQuestionAnswer([void Function(ChoiceQuestionAnswerBuilder) updates]) = _$ChoiceQuestionAnswer;

  Object? toJson() {
    return serializers.serializeWith(ChoiceQuestionAnswer.serializer, this);
  }

  static ChoiceQuestionAnswer? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(ChoiceQuestionAnswer.serializer, json);
  }

  static BuiltList<ChoiceQuestionAnswer> fromColumnMapSet(List<Map<String, dynamic>> columnMapSet) {
    final cqas = columnMapSet.map((map) => ChoiceQuestionAnswer.fromJson(map)).whereNotNull().toBuiltList();

    return cqas;
  }

  static BuiltList<ChoiceQuestionAnswer> fromMappedResultsQuery(List<Map<String, Map<String, dynamic>>> mappedResultsQuery) {
    final choiceAnswers = mappedResultsQuery
        .map((row) => row["choice_question_answer"])
        .whereNotNull()
        .map((map) => ChoiceQuestionAnswer.fromJson(map))
        .whereNotNull()
        .toBuiltList();

    return choiceAnswers;
  }

  static BuiltList<ChoiceQuestionAnswer> fromResultList(Result result) {
    final columnNames = result.schema.columns.map((column) => column.columnName!).toList();
    List<Map<String, dynamic>> jsonResult = result.map((row) => Map.fromIterables(columnNames, row)).toList();
    final choiceAnswers = jsonResult.map((map) => ChoiceQuestionAnswer.fromJson(map)).whereNotNull().toBuiltList();
    return choiceAnswers;
  }

  static Serializer<ChoiceQuestionAnswer> get serializer => _$choiceQuestionAnswerSerializer;

  ChoiceQuestionAnswer getAnswerAfterInsert({required BuiltList<ChoiceQuestionAnswer> returnedAnswersFromInsert}) {
    final answerAfterInsert = returnedAnswersFromInsert.singleWhere((newAnswer) => newAnswer.equalsAllButId(this));

    return answerAfterInsert;
  }

  ChoiceQuestionAnswer updateParentId(
      {required BuiltList<ChoiceQuestionAnswer> answersBeforeInsert, required BuiltList<ChoiceQuestionAnswer> returnedAnswersFromInsert}) {
    final parentId = this.parentId;
    if (parentId == null) {
      throw ArgumentError("[parentId] doesn't need to be updated, because [parentId] is null");
    }
    final originalParents = answersBeforeInsert.where((originalAnswer) {
      final isOriginalParent = originalAnswer.id == parentId;
      return isOriginalParent;
    }).toList();

    if (originalParents.isEmpty) {
      throw StateError("Original Vater-Frage kann nicht gefunden werden. Parent-ID: $parentId. $id : $this");
    }

    final originalParent = originalParents.single;

    final actualParent = returnedAnswersFromInsert.singleWhere((newAnswer) => newAnswer.equalsAllButId(originalParent));

    final answerWithUpdatedParentId = rebuild((b) => b.parentId = actualParent.id);

    return answerWithUpdatedParentId;
  }

  Set<ChoiceQuestionAnswer> getAnswersOfInheritingSubmissions(
      {required Submission submission, required ViewModel vm, required SurveyEntryPath path}) {
    final childAnswers = getSubmission(vm).getChildren(vm).expand((child) => child.getAnswers(vm: vm, path: path));

    return childAnswers.toSet();
  }

  @override
  Set<ChoiceQuestionAnswer> getAnswersOfInheritingSubmissionsRecursivly(
      {required Submission submission, required ViewModel vm, required SurveyEntryPath path}) {
    final answersToFindChildrenFor = Queue<ChoiceQuestionAnswer>()..add(this);

    final inheritingAnswers = <ChoiceQuestionAnswer>{};

    while (answersToFindChildrenFor.isNotEmpty) {
      final answerToFindChildrenFor = answersToFindChildrenFor.removeFirst();
      final children = answerToFindChildrenFor.getAnswersOfInheritingSubmissions(submission: submission, vm: vm, path: path);
      answersToFindChildrenFor.addAll(children);
      inheritingAnswers.addAll(children);
    }

    return inheritingAnswers;
  }
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class Concretisation implements Built<Concretisation, ConcretisationBuilder> {
  int get id;

  @BuiltValueField(wireName: "choice_question_answer_id")
  int get choiceQuestionAnswerId;

  @BuiltValueField(wireName: "order_index")
  int get orderIndex;

  @BuiltValueField(wireName: "concretisation_value")
  ConcretisationValueBase get concretisationValue;

  static BuiltList<Concretisation> fromMappedResultsQuery(List<Map<String, Map<String, dynamic>>> mappedResultsQuery) {
    final concretisations =
        mappedResultsQuery.map((row) => row["concretisation"]).whereNotNull().map((map) => Concretisation.fromJson(map)).whereNotNull().toBuiltList();

    return concretisations;
  }

  static BuiltList<Concretisation> fromResultList(Result result) {
    final columnNames = result.schema.columns.map((column) => column.columnName!).toList();
    List<Map<String, dynamic>> jsonResult = result.map((row) => Map.fromIterables(columnNames, row)).toList();
    final concretisations = jsonResult.map((map) => Concretisation.fromJson(map)).whereNotNull().toBuiltList();
    return concretisations;
  }

  Concretisation._();
  factory Concretisation([void Function(ConcretisationBuilder) updates]) = _$Concretisation;

  Object? toJson() {
    return serializers.serializeWith(Concretisation.serializer, this);
  }

  static Concretisation? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(Concretisation.serializer, json);
  }

  static Serializer<Concretisation> get serializer => _$concretisationSerializer;

  Concretisation getNewConcretisation(
      {required BuiltList<ChoiceQuestionAnswer> answersBeforeInsert, required answersAfterInsert, required Submission newSubmission}) {
    final newConcretisation = rebuild((b) {
      final oldParentId = choiceQuestionAnswerId;
      final oldAnswer = answersBeforeInsert.singleWhere((a) => a.id == oldParentId);
      final newAnswer = oldAnswer.getAnswerAfterInsert(returnedAnswersFromInsert: answersAfterInsert);
      b.choiceQuestionAnswerId = newAnswer.id;
    });
    return newConcretisation;
  }
}

@BuiltValue(instantiable: false)
abstract class ConcretisationValueBase {}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class TextConcretisation implements ConcretisationValueBase, Built<TextConcretisation, TextConcretisationBuilder> {
  String get text;

  TextConcretisation._();
  factory TextConcretisation([void Function(TextConcretisationBuilder) updates]) = _$TextConcretisation;

  Object? toJson() {
    return serializers.serializeWith(TextConcretisation.serializer, this);
  }

  static TextConcretisation? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(TextConcretisation.serializer, json);
  }

  static Serializer<TextConcretisation> get serializer => _$textConcretisationSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class DecimalConcretisation implements ConcretisationValueBase, Built<DecimalConcretisation, DecimalConcretisationBuilder> {
  String get decimal;

  DecimalConcretisation._();
  factory DecimalConcretisation([void Function(DecimalConcretisationBuilder) updates]) = _$DecimalConcretisation;

  Object? toJson() {
    return serializers.serializeWith(DecimalConcretisation.serializer, this);
  }

  static DecimalConcretisation? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(DecimalConcretisation.serializer, json);
  }

  static Serializer<DecimalConcretisation> get serializer => _$decimalConcretisationSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class ZeitVorgabeConcretisation implements ConcretisationValueBase, Built<ZeitVorgabeConcretisation, ZeitVorgabeConcretisationBuilder> {
  @BuiltValueField(wireName: 'von_tag')
  String? get vonTag;

  @BuiltValueField(wireName: 'bis_tag')
  String? get bisTag;

  @BuiltValueField(wireName: 'von_monat')
  String? get vonMonat;

  @BuiltValueField(wireName: 'bis_monat')
  String? get bisMonat;

  @BuiltValueField(wireName: 'dauer_in_stunden')
  String? get dauerInStunden;

  @BuiltValueField(wireName: 'text_concretisation')
  String? get textConcretisation;

  ZeitVorgabeConcretisation._();
  factory ZeitVorgabeConcretisation([void Function(ZeitVorgabeConcretisationBuilder) updates]) = _$ZeitVorgabeConcretisation;

  Object? toJson() {
    return serializers.serializeWith(ZeitVorgabeConcretisation.serializer, this);
  }

  static ZeitVorgabeConcretisation? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(ZeitVorgabeConcretisation.serializer, json);
  }

  static Serializer<ZeitVorgabeConcretisation> get serializer => _$zeitVorgabeConcretisationSerializer;
}

abstract class MengenVorgabeConcretisation
    implements ConcretisationValueBase, Built<MengenVorgabeConcretisation, MengenVorgabeConcretisationBuilder> {
  @BuiltValueField(wireName: 'vorz_min')
  String? get vorzeichenMin;

  @BuiltValueField(wireName: 'zahl_min')
  String get zahlMin;

  @BuiltValueField(wireName: 'vorz_max')
  String? get vorzeichenMax;

  @BuiltValueField(wireName: 'zahl_max')
  String get zahlMax;

  @BuiltValueField(wireName: 'zaehler')
  String? get zaehler;

  @BuiltValueField(wireName: 'nenner')
  String? get nenner;

  @BuiltValueField(wireName: 'text_concretisation')
  String? get textConcretisation;

  MengenVorgabeConcretisation._();
  factory MengenVorgabeConcretisation([void Function(MengenVorgabeConcretisationBuilder) updates]) = _$MengenVorgabeConcretisation;

  Object? toJson() {
    return serializers.serializeWith(MengenVorgabeConcretisation.serializer, this);
  }

  static MengenVorgabeConcretisation? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(MengenVorgabeConcretisation.serializer, json);
  }

  static Serializer<MengenVorgabeConcretisation> get serializer => _$mengenVorgabeConcretisationSerializer;
}

/// Generated by the Build Value Template: bvtsf (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class SurveyEntryPath implements Built<SurveyEntryPath, SurveyEntryPathBuilder> {
  BuiltList<SurveyEntryPathElement> get chainElements;
  String? get leafQuestion;

  @memoized
  String? get leafAnswer {
    if (leafQuestion == null && chainElements.isNotEmpty) {
      return chainElements.last.answer;
    }
    return null;
  }

  @memoized
  bool get isChoicePath => leafQuestion == null && chainElements.isNotEmpty;

  @memoized
  bool get isSubQuestionPath => leafQuestion != null && chainElements.isNotEmpty;

  @memoized
  bool get isTopLevelQuestionPath => leafQuestion != null && chainElements.isEmpty;

  @memoized
  SurveyEntryPath? get parentPath {
    if (isTopLevelQuestionPath) {
      return null;
    }

    if (isSubQuestionPath) {
      return rebuild((b) => b.leafQuestion = null);
    }

    if (isChoicePath) {
      return rebuild((b) => b
        ..leafQuestion = chainElements.last.question
        ..chainElements.removeLast());
    }

    return null;
  }

  SurveyEntryPath getChoicePath(String choiceId) {
    final choicePath = rebuild((b) => b
      ..chainElements.add(SurveyEntryPathElement((b) => b
        ..question = leafQuestion
        ..answer = choiceId))
      ..leafQuestion = null);

    return choicePath;
  }

  @memoized
  SurveyEntryPath? get parentQuestionPath {
    if (isSubQuestionPath || isTopLevelQuestionPath) {
      return parentPath?.parentPath;
    }

    if (isChoicePath) {
      return parentPath;
    }

    return null;
  }

  @memoized
  List<SurveyEntryPath> get questionPathChain {
    SurveyEntryPath? currentPath = this;
    final pathChain = <SurveyEntryPath>[];

    while (currentPath != null) {
      pathChain.add(currentPath);
      currentPath = currentPath.parentQuestionPath;
    }
    return pathChain.reversed.toList();
  }

  @memoized
  List<SurveyEntryPath> get pathChain {
    SurveyEntryPath? currentPath = this;
    final pathChain = <SurveyEntryPath>[];

    while (currentPath != null) {
      pathChain.add(currentPath);
      currentPath = currentPath.parentPath;
    }
    return pathChain.reversed.toList();
  }

  @memoized
  Question? getQuestion(QuestionsAndChoicesByPath questionsAndChoicesByPath) {
    final questionByPathMap = questionsAndChoicesByPath.questionByPathMap;
    final question = questionByPathMap[this];
    return question;
  }

  @memoized
  Choice? getChoice(QuestionsAndChoicesByPath questionsAndChoicesByPath) {
    final choicesByPathMap = questionsAndChoicesByPath.choicesByPathMap;
    final choice = choicesByPathMap[this];
    return choice;
  }

  @memoized
  String getPathString(QuestionsAndChoicesByPath questionsAndChoicesByPath) {
    final questionByPathMap = questionsAndChoicesByPath.questionByPathMap;

    final choicesByPathMap = questionsAndChoicesByPath.choicesByPathMap;

    final chainElementsString = pathChain.map((e) {
      final question = questionByPathMap[e];
      final choice = choicesByPathMap[e];

      if (question != null) {
        return question.title;
      }
      if (choice != null) {
        return choice.title;
      }
    }).join(" -> ");

    return chainElementsString;
  }

  int? getParentId({required Submission submission, required ViewModel vm}) {
    final lastSegment = chainElements.lastOrNull;

    if (lastSegment == null) {
      return null;
    }

    final secondToLastPath = parentPath;

    if (secondToLastPath == null) {
      return null;
    }

    final secondToLastChoiceAnswersFromCache = submission.getAnswers(vm: vm, path: secondToLastPath);

    final secondToLastChoiceAnswerFromCache = secondToLastChoiceAnswersFromCache.singleOrNull;

    if (secondToLastChoiceAnswerFromCache == null) {
      return null;
    }

    return secondToLastChoiceAnswerFromCache.id;
  }

  SurveyEntryPath._();
  factory SurveyEntryPath([void Function(SurveyEntryPathBuilder)? updates]) = _$SurveyEntryPath;

  SurveyEntryPath appendAnswer(Choice choice) {
    final leafQuestion = this.leafQuestion;
    if (leafQuestion == null) {
      throw StateError("It is only possible to get choice paths if the leaf question is set.");
    }

    final appendedPath = SurveyEntryPath((b) => b.chainElements = ListBuilder([
          ...chainElements,
          SurveyEntryPathElement((b) => b
            ..question = leafQuestion
            ..answer = choice.value)
        ]));
    return appendedPath;
  }

  SurveyEntryPath appendQuestion(Question question) {
    if (leafQuestion != null) {
      throw StateError("It is only possible to get choice paths if the leaf question is not set.");
    }
    return SurveyEntryPath((b) => b
      ..chainElements = ListBuilder([
        ...chainElements,
      ])
      ..leafQuestion = question.id);
  }

  Object? toJson() {
    return serializers.serializeWith(SurveyEntryPath.serializer, this);
  }

  @override
  String toString() {
    final buffer = StringBuffer();
    for (final chainElement in chainElements) {
      buffer
        ..write(chainElement.question)
        ..write("=")
        ..write(chainElement.answer)
        ..write("->");
    }
    buffer.write(leafQuestion);

    return buffer.toString();
  }

  static SurveyEntryPath? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(SurveyEntryPath.serializer, json);
  }

  static Serializer<SurveyEntryPath> get serializer => _$surveyEntryPathSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class SurveyEntryPathElement implements Built<SurveyEntryPathElement, SurveyEntryPathElementBuilder> {
  String get question;
  String get answer;

  SurveyEntryPathElement._();
  factory SurveyEntryPathElement([void Function(SurveyEntryPathElementBuilder)? updates]) = _$SurveyEntryPathElement;

  Object? toJson() {
    return serializers.serializeWith(SurveyEntryPathElement.serializer, this);
  }

  static SurveyEntryPathElement? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(SurveyEntryPathElement.serializer, json);
  }

  static Serializer<SurveyEntryPathElement> get serializer => _$surveyEntryPathElementSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class ChoiceAnswerValidationResult implements Built<ChoiceAnswerValidationResult, ChoiceAnswerValidationResultBuilder> {
  BuiltMap<SurveyEntryPath, BuiltList<QuestionError>> get errorsByPath;

  ChoiceAnswerValidationResult._();
  factory ChoiceAnswerValidationResult([void Function(ChoiceAnswerValidationResultBuilder) updates]) = _$ChoiceAnswerValidationResult;

  Object? toJson() {
    return serializers.serializeWith(ChoiceAnswerValidationResult.serializer, this);
  }

  static ChoiceAnswerValidationResult? fromJson(Object? json) {
    return serializers.deserializeWith(ChoiceAnswerValidationResult.serializer, json);
  }

  static Serializer<ChoiceAnswerValidationResult> get serializer => _$choiceAnswerValidationResultSerializer;
}

//mixin class HasValidationErrorMessage {
//  ValidationErrorMessage get errorMessage => const ValidationErrorMessage();
//}

@BuiltValue(instantiable: false)
abstract class QuestionError {
  String get questionTitle;
  BuiltList<SurveyEntryPath> get pathSegments;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class ChoiceQuestionHasNoAnswersError
    //with
    //    HasValidationErrorMessage
    implements
        QuestionError,
        Built<ChoiceQuestionHasNoAnswersError, ChoiceQuestionHasNoAnswersErrorBuilder> {
  //@override
  //ValidationErrorMessage get errorMessage =>
  //    ChoiceQuestionHasNoAnswersErrorMessage(error: this);

  ChoiceQuestionHasNoAnswersError._();
  factory ChoiceQuestionHasNoAnswersError([void Function(ChoiceQuestionHasNoAnswersErrorBuilder) updates]) = _$ChoiceQuestionHasNoAnswersError;

  Object? toJson() {
    return serializers.serializeWith(ChoiceQuestionHasNoAnswersError.serializer, this);
  }

  static ChoiceQuestionHasNoAnswersError? fromJson(Map<String, dynamic> json) {
    return serializers.deserializeWith(ChoiceQuestionHasNoAnswersError.serializer, json);
  }

  static Serializer<ChoiceQuestionHasNoAnswersError> get serializer => _$choiceQuestionHasNoAnswersErrorSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class SingelChoiceQuestionHasToManyAnswersError
    //with
    //    HasValidationErrorMessage
    implements
        QuestionError,
        Built<SingelChoiceQuestionHasToManyAnswersError, SingelChoiceQuestionHasToManyAnswersErrorBuilder> {
  //@override
  //ValidationErrorMessage get errorMessage =>
  //    SingelChoiceQuestionHasToManyAnswersErrorMessage(error: this);

  SingelChoiceQuestionHasToManyAnswersError._();
  factory SingelChoiceQuestionHasToManyAnswersError([void Function(SingelChoiceQuestionHasToManyAnswersErrorBuilder) updates]) =
      _$SingelChoiceQuestionHasToManyAnswersError;

  Object? toJson() {
    return serializers.serializeWith(SingelChoiceQuestionHasToManyAnswersError.serializer, this);
  }

  static SingelChoiceQuestionHasToManyAnswersError? fromJson(Object? json) {
    return serializers.deserializeWith(SingelChoiceQuestionHasToManyAnswersError.serializer, json);
  }

  static Serializer<SingelChoiceQuestionHasToManyAnswersError> get serializer => _$singelChoiceQuestionHasToManyAnswersErrorSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class ChoiceQuestionHasDuplicateAnswersError
    //with
    //    HasValidationErrorMessage
    implements
        QuestionError,
        Built<ChoiceQuestionHasDuplicateAnswersError, ChoiceQuestionHasDuplicateAnswersErrorBuilder> {
  //@override
  //ValidationErrorMessage get errorMessage =>
  //    ChoiceQuestionHasDuplicateAnswersErrorMessage(error: this);

  BuiltSet<String> get duplicateAnswers;

  ChoiceQuestionHasDuplicateAnswersError._();
  factory ChoiceQuestionHasDuplicateAnswersError([void Function(ChoiceQuestionHasDuplicateAnswersErrorBuilder) updates]) =
      _$ChoiceQuestionHasDuplicateAnswersError;

  Object? toJson() {
    return serializers.serializeWith(ChoiceQuestionHasDuplicateAnswersError.serializer, this);
  }

  static ChoiceQuestionHasDuplicateAnswersError? fromJson(Object? json) {
    return serializers.deserializeWith(ChoiceQuestionHasDuplicateAnswersError.serializer, json);
  }

  static Serializer<ChoiceQuestionHasDuplicateAnswersError> get serializer => _$choiceQuestionHasDuplicateAnswersErrorSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class ChoiceQuestionHasAnswersButPathIsDisabledError
    //with
    //    HasValidationErrorMessage
    implements
        QuestionError,
        Built<ChoiceQuestionHasAnswersButPathIsDisabledError, ChoiceQuestionHasAnswersButPathIsDisabledErrorBuilder> {
  BuiltList<SurveyEntryPath> get disabledPathSegments;

  //@override
  //ValidationErrorMessage get errorMessage =>
  //    ChoiceQuestionHasAnswersButPathIsDisabledErrorMessage(error: this);

  ChoiceQuestionHasAnswersButPathIsDisabledError._();
  factory ChoiceQuestionHasAnswersButPathIsDisabledError([void Function(ChoiceQuestionHasAnswersButPathIsDisabledErrorBuilder) updates]) =
      _$ChoiceQuestionHasAnswersButPathIsDisabledError;

  Object? toJson() {
    return serializers.serializeWith(ChoiceQuestionHasAnswersButPathIsDisabledError.serializer, this);
  }

  static ChoiceQuestionHasAnswersButPathIsDisabledError? fromJson(Object? json) {
    return serializers.deserializeWith(ChoiceQuestionHasAnswersButPathIsDisabledError.serializer, json);
  }

  static Serializer<ChoiceQuestionHasAnswersButPathIsDisabledError> get serializer => _$choiceQuestionHasAnswersButPathIsDisabledErrorSerializer;
}

/// Generated by the Build Value Template: bvts (Built Value Type Serializable File whose name corresponds to the file name)
/// Plugin: Built Value Snippets
/// https://plugins.jetbrains.com/plugin/13786-built-value-snippets
abstract class PathIsDisabledButHasAnsweredSubquestionsError
    //with
    //    HasValidationErrorMessage
    implements
        QuestionError,
        Built<PathIsDisabledButHasAnsweredSubquestionsError, PathIsDisabledButHasAnsweredSubquestionsErrorBuilder> {
  //@override
  //ValidationErrorMessage get errorMessage =>
  //    PathIsDisabledButHasAnsweredSubquestionsErrorMessage(error: this);

  SurveyEntryPath get subQuestionPath;
  BuiltList<SurveyEntryPath> get disabledPathSegments;

  PathIsDisabledButHasAnsweredSubquestionsError._();
  factory PathIsDisabledButHasAnsweredSubquestionsError([void Function(PathIsDisabledButHasAnsweredSubquestionsErrorBuilder) updates]) =
      _$PathIsDisabledButHasAnsweredSubquestionsError;

  Object? toJson() {
    return serializers.serializeWith(PathIsDisabledButHasAnsweredSubquestionsError.serializer, this);
  }

  static PathIsDisabledButHasAnsweredSubquestionsError? fromJson(Object? json) {
    return serializers.deserializeWith(PathIsDisabledButHasAnsweredSubquestionsError.serializer, json);
  }

  static Serializer<PathIsDisabledButHasAnsweredSubquestionsError> get serializer => _$pathIsDisabledButHasAnsweredSubquestionsErrorSerializer;
}
